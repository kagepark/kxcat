####################################
# License : GPL
####################################

get_freeip() {
    group_ips=()
    group_ips_str=""
    group_num=""
    for ii in $(tabdump hosts | grep -v "^#" | awk -F, '{if($2) print $2}'| sed "s/(((\$1\/256)\%256)//g" | sed "s/((\$1%256//g" |  sed -e "s/+//g" -e "s/)//g" | awk -F\| '{print $2}'); do
        group_ips_str="$group_ips_str
$(_k_net_str2ip $ii)"
    done
    group_ips=($(echo "$group_ips_str" | sort -n))
    for ((ii=0;ii<$((${#group_ips[*]}-1));ii++)); do
        if (( $(( ${group_ips[$ii+1]} - ${group_ips[$ii]} )) >= $(( $(( $MAX_NODES + 50 )) * 2 )) )); then
            group_num=$ii
            GROUP_START=$((${group_ips[$ii]} + $MAX_NODES + 50))
            break
        fi
    done

    if [ ! -n "$group_num" ]; then
        group_num=${#group_ips[*]}
        (($group_num > 0)) && GROUP_START=$((${group_ips[$((${#group_ips[*]}-1))]} + $MAX_NODES + 50)) || GROUP_START=100
    fi
    #GROUP_START_1=$(($(($GROUP_START/256))%256))
    #GROUP_START_2=$(($GROUP_START%256))
    if [ -n "$BMC_NETWORK" ]; then
       BMC_NET_1=$(echo $BMC_NETWORK | awk -F. '{print $3}')
       (( $(( $(_k_net_str2ip $BMC_NETWORK) - $MAX_NODES + 200)) < $(( $(( $group_num * $MAX_NODES )) + $(($group_num * 50)) + 100 )) )) && exit 1 || echo "$GROUP_START $group_num"
    else
        echo "$GROUP_START $group_num"
    fi
}


gen_create() {
    local hostname opt
    old_group=$1
    new_group=$2
    file=$3

    get_free_ip=$(get_freeip) ||  error_exit "No more free network IP"
    get_free_ips=($get_free_ip)
    group_num=${get_free_ips[1]}
    GROUP_START=${get_free_ips[0]}
    

    GROUP_START_1=$(($(($GROUP_START/256))%256))
    GROUP_START_2=$(($GROUP_START%256))

    [ -d /install/groups ] || mkdir -p /install/groups
    if [ -n "$file" -a -f "$file" ]; then
       cat $file | sed "s/^[^ ]\+:/${new_group}:/" | sed "s#/${old_group}/#/$new_group/#g" | mkdef -z
    else
       lsdef -t osimage -z ${old_group} | sed "s/^[^ ]\+:/${new_group}:/" | mkdef -z
    
       mkdir -p /install/groups/${new_group}/env
       chdef -t osimage ${new_group} rootimgdir=/install/groups/${new_group}
       env_files=""
       for ii in $(lsdef -t osimage ${old_group} -i exlist,pkglist,otherpkglist,synclists,postscripts,postinstall,template | grep -v "^Object name:"); do
          src_file=$(echo $ii | awk -F= '{print $2}')
          src_type=$(echo $ii | awk -F= '{print $1}')
          env_files="$env_files ${src_type}="
          if [ -n "$src_file" ]; then
             multi_file=0
             for jj in $(echo $src_file | sed "s/,/ /g"); do
               if [ "$multi_file" == "0" ]; then
                 jj_real=$(_k_misc_get_realpath $jj)
                 if [ -n "$jj_real" -a -e "$jj_real" ]; then
                     if [ "$src_type" == "synclists" ]; then
                         if [ "$jj" == "$_KXC_HOME/share/hpc_syncfile" ]; then
                             env_files="${env_files}$jj"
                             synclist_chk=1
                         else
                             cp -a $(_k_misc_get_realpath $jj) /install/groups/$new_group/env/$(basename $jj) && ( [ "$synclist_chk" == "1" ] && env_files="${env_files},/install/groups/$new_group/env/$(basename $jj)" || env_files="${env_files}/install/groups/$new_group/env/$(basename $jj),${_KXC_HOME}/share/hpc_syncfile" )
                             multi_file=1
                         fi
                     else
                         synclist_chk=0
                         #cp -a $(_k_misc_get_realpath $jj) /install/groups/$new_group/env/$(basename $jj) && env_files="${env_files}/install/groups/$new_group/env/$(basename $jj)"
                         env_file="/install/groups/$new_group/env/$(basename $jj)"
                         cp -a $(_k_misc_get_realpath $jj) $env_file && env_files="${env_files}$env_file"
                         multi_file=1
                         if [ "$src_type" == "pkglist" ]; then
                             if [ "$base_pkg" != "1" ]; then
                               #grep "^#INCLUDE:$_KXC_HOME/share/hpc_pkglist#$" /install/groups/$new_group/env/$(basename $jj) >& /dev/null || echo "#INCLUDE:$_KXC_HOME/share/hpc_pkglist#" >> /install/groups/$new_group/env/$(basename $jj)
                               grep "^#INCLUDE:$_KXC_HOME/share/hpc_pkglist#$" $env_file >& /dev/null || echo "#INCLUDE:$_KXC_HOME/share/hpc_pkglist#" >> $env_file
                               if [ -n "$pkglist_str" ]; then
                                  for ii in $(echo $pkglist_str | sed "s/,/ /g"); do
                                       #grep "^#INCLUDE:${ii}#$" /install/groups/$new_group/env/$(basename $jj) >& /dev/null || \
                                       #   echo "#INCLUDE:${ii}#" >> /install/groups/$new_group/env/$(basename $jj)
                                       grep "^#INCLUDE:${ii}#$" $env_file >& /dev/null || \
                                          echo "#INCLUDE:${ii}#" >> $env_file
                                  done
                               fi
                             fi
                         elif [ "$src_type" == "exlist" ]; then
                             sed -i -e "/.\/usr\/include/d" -e "/.\/usr\/share\/man/d" -e "/.\/usr\/local/d" -e "/.\/boot/d" $env_file
                         fi
                     fi
                 else
                     echo "$jj not found"
                 fi
               else
                 if [ "$_KXC_HOME/share/hpc_syncfile" != "$jj" ]; then
                    jj_real=$(_k_misc_get_realpath $jj)
                    if [ -n "$jj_real" -a -e "$jj_real" ]; then
                       #cp -a "$jj_real" /install/groups/$new_group/env/$(basename $jj) && env_files="${env_files},/install/groups/$new_group/env/$(basename $jj)"
                       env_file="/install/groups/$new_group/env/$(basename $jj)"
                       cp -a "$jj_real" $env_file && env_files="${env_files},$env_file"
                    else
                       echo "$jj not found"
                    fi
                 fi
               fi
             done
          else
             if [ "$src_type" == "synclists" ]; then
               env_files="${env_files}$_KXC_HOME/share/hpc_syncfile"
             fi
          fi
       done
    fi

    [ -n "$env_files" ] && chdef -t osimage ${new_group} $env_files

    GROUP_NETWORK_IP=$(echo $(_k_net_ip $GROUP_NETWORK $GROUP_NETMASK) | sed "s/ //g")
    if [ -n "$MPI_NETWORK" ]; then
       MPI_NETWORK_IP=$(echo $(_k_net_ip $MPI_NETWORK $GROUP_NETMASK) | sed "s/ //g")
       MPI_NETWORK_IP_STR="otherinterfaces=|${new_group}(sprintf('-%04d',\$1))-${MPI_DEV}:${MPI_NETWORK_IP}.(((\$1/256)%256)+$GROUP_START_1).((\$1%256)+$GROUP_START_2)|"
    fi
    #chdef -t group ${new_group} ip="|${GROUP_NETWORK_IP}.(((\$1/256)%256)+$GROUP_START_1).((\$1%256)+$GROUP_START_2)|"
    chdef -t group ${new_group} ip="|${GROUP_NETWORK_IP}.(((\$1/256)%256)+$GROUP_START_1).((\$1%256)+$GROUP_START_2)|" $MPI_NETWORK_IP_STR
    [ -d /global/xcat_boot.d/${new_group} ] || mkdir -p /global/xcat_boot.d/${new_group}
    ssh_key=$(cat /etc/ssh/ssh_host_rsa_key.pub)
    for ((ii=1; ii<${MAX_NODES}; ii++)); do
        echo "${new_group}-$(printf "%04d" $ii) $ssh_key" >> /etc/ssh/ssh_known_hosts
        [ -n "$MPI_NETWORK" ] && echo "${new_group}-$(printf "%04d" $ii)-ib0 $ssh_key" >> /etc/ssh/ssh_known_hosts
    done
}

make() {
    local hostname opt new_group old_group pkglist_str postinstall_str base_pkg clone_boot_script
    opt=($*)
    if (( ${#opt[*]} < 2 || ${#opt[*]} > 3 )); then
         echo "${FUNCNAME} <group> <Image> [pkglist=<pkglist file1>,<pkglist file2>,....] [-b]"
         echo "  -b : xCAT base package list only"
#         echo "${FUNCNAME} <group> <Image>"
         echo
         echo "   get image names : scix images"
         exit
    fi

    group=$1
    [ "$group" == "n" ] && error_exit "not support group 'n'"
    shift 1
    image=$1
    shift 1
    for ii in $*; do
        pkglist_str=$(echo $ii | awk -F= '{if($1=="pkglist") print $2}')
        postinstall_str=$(echo $ii | awk -F= '{if($1=="postinstall") print $2}')
        [ "$ii" == "-b" ] && base_pkg=1
    done

    [ -n "$(echo "$group" | sed "s/[^0-9]*//g")" ] && error_exit "Group name not support digital number. Please remove any number in group name string"
    for ii in netboot; do
        [ "$group" == "$ii" ] && error_exit "xCAT not support $group name"
    done
    if [ -n "$pkglist_str" ]; then
       for ii in $(echo $pkglist_str | sed "s/,/ /g"); do
          [ -f $ii ] || error_exit "$ii not found for pkglist"
       done
    fi
    if ! lsdef -t osimage $image >& /dev/null; then
         echo "$image not found"
         exit
    fi
    if lsdef -t group $group >& /dev/null; then
         echo "Alread $group exist"
         exit
    fi
    if lsdef -t osimage $group >& /dev/null; then
         echo "Alread $group image exist"
         exit
    fi

    type=$(lsdef -t osimage ${image} -i provmethod | sed "s/ //g" | awk -F= '{if($1 == "provmethod") print $2}')
    gen_create "$image" "$group"  $@
    if [ "$type" == "netboot" ]; then
        genimage ${new_group}
        for jj in firewalld iptable NetworkManager libvirtd; do
           for ii in $(find /install/groups/${new_group}/rootimg/etc/systemd/system -name "${jj}*"); do
              rm -f $ii
           done
        done
        packimage ${new_group}
    elif [ "$type" == "statelite" ]; then
        echo
    fi
}

clone() {
    local hostname opt new_group old_group pkglist_str postinstall_str base_pkg clone_boot_script
    opt=($*)
    if (( ${#opt[*]} < 2 || ${#opt[*]} > 4 )); then
         echo "${FUNCNAME} <new group> <old group> [pkglist=<pkglist file1>,<pkglist file2>,....] [-b] [-a]"
         echo "  -b : xCAT base package list only"
         echo "  -a : clone with xcat_boot.d scripts"
         exit
    fi

    new_group=$1
    old_group=$2
    shift 2
    for ii in $*; do
        pkglist_str=$(echo $ii | awk -F= '{if($1=="pkglist") print $2}')
        postinstall_str=$(echo $ii | awk -F= '{if($1=="postinstall") print $2}')
        [ "$ii" == "-b" ] && base_pkg=1
        [ "$ii" == "-a" ] && clone_boot_script=1
    done
#    [ "$1" == "-b" ] && clone_boot_script=1

    if [ -n "$pkglist_str" ]; then
       for ii in $(echo $pkglist_str | sed "s/,/ /g"); do
          [ -f $ii ] || error_exit "$ii not found for pkglist"
       done
    fi
    if ! lsdef -t group $old_group >& /dev/null; then
         echo "Not found $old_group"
         exit
    fi
    if ! lsdef -t osimage $old_group >& /dev/null; then
         echo "Not found $old_group image"
         exit
    fi
    if lsdef -t group $new_group >& /dev/null; then
         echo "Alread $new_group exist"
         exit
    fi
    if lsdef -t osimage $new_group >& /dev/null; then
         echo "Alread $new_group image exist"
         exit
    fi
    [ "$new_group" == "n" ] && error_exit "not support group 'n'"
    if [ "$clone_boot_script" == "1" ]; then
       [ -d /global/xcat_boot.d/${old_group} ] || error_exit "/global/xcat_boot.d/${old_group} directory not found"
       [ -d /global/xcat_boot.d/${new_group} ] && rm -fr /global/xcat_boot.d/${new_group}
       cp -a /global/xcat_boot.d/${old_group}  /global/xcat_boot.d/${new_group}
    else
       [ -d /global/xcat_boot.d/${new_group} ] || mkdir -p /global/xcat_boot.d/${new_group}
    fi
    type=$(lsdef -t osimage ${old_group} -i provmethod | sed "s/ //g" | awk -F= '{if($1 == "provmethod") print $2}')
    if [ "$type" == "netboot" -o "$type" == "statelite" ]; then
        rootimg_dir=$(lsdef -t osimage ${old_group} -i rootimgdir | tail -n1 | sed -e "s/rootimgdir=//g" -e "s/ //g")
        if [ -n "$rootimg_dir" -a -d "$rootimg_dir" ]; then
            [ -d /install/group ] || mkdir -p /install/group
            cp -a ${rootimg_dir} /install/groups/$new_group || \
            error_exit "root image cloning fail"
        fi
    fi
    gen_create "$old_group" "$new_group"
    if [ "$type" == "netboot" ]; then
    #    genimage ${new_group}
        packimage ${new_group}
    elif [ "$type" == "statelite" ]; then
        echo
    fi
}

pkg_move() {
   group_name=$1
   pkg_type=$2

   img_info_file=/install/groups/$group_name/org_image.info
   [ -f "$img_info_file" ] || return 1
   for pkg_dir in $(cat $img_info_file  | awk -F= -v ptype=$pkg_type '{if($1==ptype) print $2}' | sed "s/,/ /g"); do
      image_pkg_dir=/install/groups/$group_name/pkgs/$(basename $pkg_dir).${pkg_type}
      if [ -n "$pkg_dir" -a -n "$image_pkg_dir" -a ! -d "$pkg_dir" -a -d "$image_pkg_dir" ]; then
         mkdir -p $(dirname $pkg_dir)
         mv $image_pkg_dir $pkg_dir
      fi
   done
}

import_img() {
   group_name=$1
   image_file=$2
   no_boot_script=$3

   [ ! -n "$group_name" -o ! -n "$image_file" ] && error_exit "$(basename $0) <group name> <image file> [-nbs]"

   [ -f "$image_file" ] || error_exit "$image_file not found"
   req_free_space=$(tar --test-label -f $image_file | sed "s/KB//g" | awk -F\. '{print $1}')
   free_space=$(df -hk /install | grep -v Filesystem | awk '{print $4}')
   (( $free_space < $(($req_free_space * 2)) )) && error_exit "No enough free space for /install directory"
   lsdef -t osimage $group_name >& /dev/null && error_exit "Already $group_name exist"
   [ -d /install/groups/$group_name ] && mv /install/groups/$group_name  /install/groups/${group_name}.DEL
   mkdir -p /install/groups/$group_name
   tar zxf $image_file -C /install/groups/$group_name
   if [ ! -f /install/groups/$group_name/image.info ]; then
       rm -fr /install/groups/$group_name
       error_exit "image.info file not found"
   fi
   old_group=$(grep ":$" /install/groups/$group_name/image.info |awk -F: '{print $1}')
   gen_create "$old_group" "$group_name" "/install/groups/$group_name/image.info"
   if [ -d /install/groups/$group_name/env ]; then
      unset env_update
      declare -A env_update
      for ii in $(ls /install/groups/$group_name/env/*.env.* 2>/dev/null); do
         env_file_arr=($(echo $ii | sed "s/\.env\./ /g"))
         [ -n "${env_update[${env_file_arr[1]}]}" ] && env_update[${env_file_arr[1]}]="${env_update[${env_file_arr[1]}]},${env_file_arr[0]}" || env_update[${env_file_arr[1]}]=${env_file_arr[0]}
         mv $ii ${env_file_arr[0]}
      done
      for ii in ${!env_update[@]}; do
         chdef -t osimage ${group_name} ${ii}=${env_update[$ii]}
      done
   fi
   chdef -t osimage ${group_name} rootimgdir=/install/groups/${group_name}
   if [ -d /install/groups/$group_name/pkgs ]; then
      pkg_move "$group_name" "pkgdir" || error_exit "org_image.info file not found"
      pkg_move "$group_name" "otherpkgdir" || error_exit "org_image.info file not found"
   fi
   if [ "$no_boot_script" != "-nbs" ]; then
      [ -d /install/groups/$group_name/xcat_boot.d/image ] && cp -a /install/groups/$group_name/xcat_boot.d/image/* /global/xcat_boot.d/$group_name
      if [ -d /install/groups/$group_name/xcat_boot.d/global ]; then
         cp -a /install/groups/$group_name/xcat_boot.d/image/* /global/xcat_boot.d/$group_name
      fi
      if [ -d /install/groups/$group_name/xcat_boot.d/postscripts ]; then
         cp -a /install/groups/$group_name/xcat_boot.d/postscripts/* /global/xcat_boot.d/$group_name
      fi 
   fi
}
